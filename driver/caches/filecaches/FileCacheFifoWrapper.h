//
// Created by Pirmin Schmid on 22.09.17.
//

#ifndef DV_CACHES_FILECACHES_FILECACHEFIFOWRAPPER_H_
#define DV_CACHES_FILECACHES_FILECACHEFIFOWRAPPER_H_

#include "../../DVForwardDeclarations.h"
#include "FileCache.h"
#include "FileDescriptor.h"
#include "../../toolbox/LinkedMap.h"

namespace dv {

	/**
	 * Cache implementation that prevents unnecessary cache flushes by bulk generation of
	 * files that were not requested by clients.
	 *
	 * The wrapper consists of:
	 * - waiting list (same functionality as in all other cache implementations here)
	 * - FIFO queue (new: takes freshly generated files that were not requested by clients)
	 * - actual embedded cache (can be any of the available FileCache types)
	 *
	 * Notes:
	 * 1) The actual cache size of the system is FIFO queue size + embedded cache size.
	 * 2) The FIFO queue size should be at least as large as
	 *    number_of_simulators_in_parallel * size_of_restart_interval + 1
	 * 3) clients have the time of FIFO queue size * simulators_file_generation_frequency
	 *    to also pick up files in the FIFO queue to the actual embedded cache
	 *    -> this is enough for forward and backward trajectories for reasonable
	 *       combinations of these parameters and client_file_access_frequency
	 *    -> it may not work well for mismatches of these parameters
	 *       (e.g. large number of quickly producing simulators in parallel and
	 *       very slow clients)
	 *
	 * case distinctions:
	 * - for new file descriptors (put):
	 *   . file available and requested (see use count > 0) -> put into embedded cache
	 *     (including eviction of the cache as determined by algorithm if full)
	 *   . file available but not requested (use count == 0 -> put into FIFO queue
	 *     (which leads to the eviction of the LRU file of this queue if it is full)
	 *   . file not yet available but requested -> put into waiting list as before
	 *
	 * - for updates (refresh):
	 *   . file in waiting list; new available and requested -> move into embedded cache
	 *   . file in waiting list; new available but not requested -> move into FIFO queue
	 *   . file in FIFO queue; new requested by client -> move into embedded cache
	 *     (all including evictions if needed)
	 *   . file in embedded queue: move to MRU (refresh)
	 *   . file in FIFO queue but not requested by client (freshly generated by simulator)
	 *     -> move to MRU (refresh)
	 *
	 * Lookups must be done in 3 locations in this order:
	 * 1) embedded cache
	 * 2) FIFO queue
	 * 3) waiting list
	 *
	 * Note: the existing waiting list in the embedded queues will not be used due to
	 * the flags (file available) of the submitted files to this embedded cache.
	 *
	 * And final note: The FIFO queue is again a LinkedMap since both feature sets
	 * must be provided: FIFO and hashmap.
	 *
	 * v1.0 2017-09-22 / 2017-09-23 ps
	 */

	class FileCacheFifoWrapper : public FileCache {
	public:
		typedef toolbox::LinkedMap<std::string, std::unique_ptr<FileDescriptor>> fifo_queue_type;
		typedef fifo_queue_type::ID_type ID_type;

		typedef std::unordered_map<std::string, std::unique_ptr<FileDescriptor>> waiting_map_type;

		FileCacheFifoWrapper(DV *dv_ptr, std::unique_ptr<FileCache> embedded_cache, dv::id_type queue_capacity);

		virtual void initializeWithFiles() override;

		virtual void put(const std::string &key, std::unique_ptr<FileDescriptor> value) override;

		virtual FileDescriptor *get(const std::string &key) override;

		virtual FileDescriptor *internal_lookup_get(const std::string &key) override;

		virtual void refresh(const std::string &key) override;

		virtual const std::vector<std::string> &getAccessTrace() const override;

		virtual const std::string &name() const override;

		virtual dv::id_type capacity() const override;

		virtual dv::id_type size() const override;

		virtual Stats getStats() const override;

		virtual void printStatus(std::ostream *out) override;

		virtual const toolbox::KeyValueStore &getStatusSummary() override;

	private:
		static constexpr char kCacheName[] = "FIFO queue wrapper with ";

		DV *dv_ptr_;
		std::unique_ptr<FileCache> embedded_cache_;
		fifo_queue_type fifo_queue_;
		waiting_map_type waiting_;

		bool debug_messages_;
		std::string cache_name_;

		std::vector<std::string> access_trace_;

		toolbox::KeyValueStore statusSummary_;

		void fifoQueueAdd(const std::string &key, std::unique_ptr<FileDescriptor> value);
	};

}

#endif //DV_CACHES_FILECACHES_FILECACHEFIFOWRAPPER_H_
